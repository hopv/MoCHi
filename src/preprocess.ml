open Util
open Mochi_util
open Preprocess_common

type nonrec t = t

(** Print types without checking the type consistency *)
module Debug_ty_wo_check = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".ty_wo_check")
end)

let all = Flag.Debug.make_check (__MODULE__ ^ ".all")

(** Print types and check the type consistency *)
module Debug_ty = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".ty") ||| all
end)

(** Check the consistency of free variablse *)
module Debug_fv = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".fv") ||| all
end)

(** Check the non-existence of LDot and LApp after extracting modules *)
module Debug_lid = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".lid") ||| all
end)

(** Print results even for unchanged cases *)
module Debug_tree = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".tree")
end)

(** Print problems by Problem.pp *)
module Debug_pp = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".pp")
end)

(** Print counterexamples one-by-one (Calculation of counterexamples will be forced) *)
module Debug_cex = Debug.Make (struct
  let check = Flag.Debug.make_check (__MODULE__ ^ ".cex")
end)

module Debug = Debug.Make (struct
  let check = Flag.Debug.make_check __MODULE__
end)

let all () : t list =
  let open Trans_problem in
  [
    Init,
      ("Init",
       id);
    Abstract_menhir, (* TODO: must check the existence of assert/raise *)
      ("Abstract functions generated by Menhir",
       if_ !Flag.Abstract.menhir @@
       map_term Trans.abst_menhir);
    Set_to_primitive,
      ("Translate set functions to primitive operations",
       if_ !Flag.Method.use_set_theory @@
       map_term Trans.set_to_primitive);
    Abstract_magical_functions,
      ("Abstract Obj.magic",
       map_term Trans.abst_magic);
    Abstract_first_class_module,
      ("Abstract first-class modules",
       map Module.abst_first_class_module);
    Inline_functor,
      ("Inline functor",
       map_option Functor.inline);
    Extract_include,
      ("Extract include",
       map Module.extract_include);
    Extract_module,
      ("Extract module",
       map Module.extract);
    Instansiate_weak_poly_types,
      ("Instansiate weakly polymorphic types",
       map_term Trans.instansiate_weak_poly_types);
    Abstract_polymorphic_variant,
      ("Abstract polymorphic variant",
       map_term Trans.abst_poly_variant);
    Abstract_GADT,
      ("Abstract GADT",
       map GADT.abstract);
    Inline_tvar, (* for polymorphic first-class modules *)
      ("Inline type variables",
       map_term Trans.inline_tvar);
    Lift_type_decl,
      ("Lift type decl",
       map_term Trans.lift_type_decl);
    Ref_type_pred_type_check,
      ("Type check of refinement type predicates",
       map Ref_type_pred_typing.ref_type_pred_typing);
    Inline_type_alias,
      ("Inline type aliases",
       map_term Trans.inline_type_alias);
    Inline_ext_rebind,
      ("Inline rebinding of exception constructors",
       map_term Trans.inline_ext_rebind);
    Inline_exn_type,
      ("Inline exception type",
       map_term Trans.inline_exn_type);
    Set_main,
      ("Set main",
       map_lazy_list_with_info set_main);
  (*
    Split_by_ref_type,
      ("Split by refinement types",
       map_list_option split_by_ref_type);
  *)
    Eliminate_unused_let,
      ("Eliminate unused let",
       map_lazy_list ~op:Or elim_unused_let);
    Reduce_fail_free,
      ("Reduce fail free",
       if_ (not !Flag.Method.modular) @@
       map_option reduce_fail_free);
    Insert_extra_param,
      ("Insert extra parameters",
       if_ !Flag.Method.relative_complete @@
       map_term Trans.insert_extra_param);
    Encode_bool_as_int,
      ("Encode bool as int",
       if_ !Flag.Encode.bool_to_int @@
       map_term Trans.encode_bool_as_int);
    Replace_const,
      ("Replace const",
       if_ !Flag.Method.replace_const @@
       map CFA.replace_const);
    Rename_target_ext_funs,
      ("Rename target external functions",
       map rename_target_ext_funs);
    Copy_poly_values,
      ("Copy polymorphic values",
       map_with_get_rtyp @@ copy_poly_values);
    Copy_poly_type,
      ("Copy polymorphic types",
       map_term Trans.copy_poly_type);
    Add_ref_check,
      ("Add assert and assume for refinement types",
       map_with_trans_cex add_ref_check);
    Slice_top_fun,
      ("Slice by top-level function definitions",
       if_ !Flag.Method.sub @@
       Prep_dslice.slice_top_fun);
    Slice_top_fun,
      ("Slice by top-level function definitions based on hops",
       if_ !Flag.Method.sub_hops @@
       map_lazy_list_with_info ~op:Or Prep_dslice.slice_top_fun_by_hops);
    Set_main_sliced,
      ("Set main for slice",
       if_ !Flag.Method.sub @@
       map_lazy_list_gen Prep_dslice.set_main Option.some);
    Elim_unused_assumption,
      ("Eliminate unused assumptions",
       map elim_unused_assumption);
    Encode_lazy,
      ("Encode lazy",
       map Encode.lazy_);
    Reduce_external,
      ("Reduce external functions",
       map reduce_external);
    Abst_literal,
      ("Abstract literal",
       map_term Trans.abst_literal);
    Encode_mutable_record,
      ("Encode mutable record",
       map Encode.mutable_record);
    Inline_simple_types,
      ("Inline simple types",
       map inline_simple_types);
    Abst_recursive_record,
      ("Abstract recursive record",
       map Encode.abst_rec_record);
    Inline_record_type,
      ("Inline record type",
       map inline_record_type);
    Encode_record,
      ("Encode record",
       map Encode.record);
    Encode_array,
      ("Encode array",
       map Encode.array);
    Merge_deref,
      ("Merge dereferences",
       map_option merge_deref);
    Abst_ref,
      ("Abstract ref",
       map Encode.abst_ref);
    Abst_object,
      ("Abstract objects",
       map Encode.abst_obj);
    Make_fun_tuple,
      ("Make fun tuple",
       if_ !Flag.Method.tupling @@
       map @@ Problem.map Ref_trans.make_fun_tuple);
    Ignore_non_termination,
      ("Ignore non termination",
       if_ !Flag.Method.ignore_non_termination @@
       map_term Trans.ignore_non_termination);
    Eliminate_redundant_arguments,
      ("Eliminate redundant arguments",
       if_ !Flag.Method.elim_redundant_arg @@
       map_term Trans.elim_redundant_arg);
    Recover_const_attr,
      ("Recover const attr",
       map_term Trans.recover_const_attr);
    Decomp_pair_eq,
      ("Decomp pair eq",
       map_term Trans.decomp_pair_eq);
    Add_preds,
      ("Add preds",
       map_option (add_preds Spec.get_abst_env));
    Replace_data_with_int_but_exn,
      ("Replace data with int except exceptions",
       if_ !Flag.Abstract.data_to_int_but_exn @@
       map replace_data_with_int_but_exn);
    Abstract_exn, (* TODO: trans env *)
      (* Must precede Encode_simple_variant, Replace_data_with_int *)
      ("Abstract exceptions",
       if_ !Flag.Abstract.exn_to_bool @@
       map_term Trans.abstract_exn);
    Ignore_data_arg,
      ("Ignore arguments of data type constructors",
       if_ !Flag.Abstract.ignore_data_arg @@
       map_term Encode.ignore_data_arg);
    Ignore_excep_arg,
      ("Ignore arguments of exceptions",
       if_ !Flag.Abstract.ignore_exn_arg @@
       map_term Encode.ignore_exn_arg);
    Ignore_excep_fun_arg,
      ("Ignore function arguments of exceptions",
       map_term Encode.ignore_exn_fun_arg);
    Ignore_excep_fun_arg,
      ("Ignore recursive arguments of exceptions",
       map_term Encode.ignore_rec_exn_arg);
    Make_ext_funs,
      ("Generate external functions",
       if_ (not !Flag.Method.encode_before_make_ext_fun) @@
       map_with_trans_cex make_ext_funs);
    Encode_enum_variant,
      ("Encode enum variant 1",
       map Encode.enum_variant);
    Encode_nonrec_variant,
      ("Encode non-recursive variant 1",
       map Encode.nonrec_variant);
    Replace_base_with_int,
      ("Replace base with int",
       if_ Flag.Abstract.(!base_to_int || !data_to_int) @@
       map replace_base_with_int);
    Inline_simple_types,
      ("Inline simple types 1",
       map inline_simple_types);
    Replace_list_with_int,
      ("Replace lists with int",
       if_ !Flag.Abstract.list_to_int @@
       map replace_list_with_int);
    Replace_data_with_int,
      ("Replace data with int",
       if_ !Flag.Abstract.data_to_int @@
       map replace_data_with_int);
    Replace_complex_data_with_int, (* TODO: trans env *)
      ("Replace non-regular data with int",
       if_ !Flag.Abstract.complex_data_to_int @@
       map_term Trans.replace_complex_data_with_int);
    Inline_simple_types,
      ("Inline simple types 2",
       map inline_simple_types);
    Ignore_mutual_data_arg,
      ("Ignore arguments of mutually recursive data",
       map_term Encode.ignore_mutual_data_arg);
    Encode_enum_variant, (* This can be removed? *)
      ("Encode enum variant 2",
       map Encode.enum_variant);
    Encode_nonrec_variant, (* This can be removed? *)
      ("Encode non-recursive variant 2",
       map Encode.nonrec_variant);
    Encode_recdata,
      ("Encode recdata",
       map Encode.recdata);
    Encode_option,
      ("Encode option",
       map Encode.option);
    Inline_type_decl,
      ("Inline type decl",
       map_term Trans.inline_type_decl);
    Encode_list,
      ("Encode list",
       map_with_get_rtyp Encode.list);
    Merge_branch,
      ("Merge the same branches 1",
       map_term Trans.merge_branch);
    Replace_abst_with_int,
      ("Replace abstract types with int",
       map replace_abst_with_int);
    Abst_div,
      ("Abstract division",
       if_ !Flag.Abstract.div @@
       map_term Trans.abst_div);
    Unify_pure_fun_app,
      ("Unify applications of pure functions",
       map_term Trans.unify_pure_fun_app);
    Ret_fun,
      ("Ret fun",
       if_ !Flag.Method.tupling @@
       map_with_get_rtyp @@ Problem.map_on Focus.fst Ret_fun.trans);
    Ref_trans,
      ("Ref trans",
       if_ !Flag.Method.tupling @@
       map_with_get_rtyp @@ Problem.map_on Focus.fst Ref_trans.trans);
    Tupling,
      ("Tupling",
       if_ !Flag.Method.tupling @@
       map_with_get_rtyp @@ Problem.map_on Focus.fst Tupling.trans);
    Inline,
      ("Inline",
       map inline);
    Make_ext_funs,
      ("Generate external functions",
       if_ !Flag.Method.encode_before_make_ext_fun @@
       map_with_trans_cex make_ext_funs);
    Reduce_rand,
      ("Reduce rand",
       map_with_trans_cex reduce_rand);
    Reduce_ignore,
      ("Reduce ignore",
       map_term Trans.reduce_ignore);
    Reduce_branch,
      ("Reduce branch",
       map_term Trans.reduce_branch);
    Split_assert,
      ("Split assert",
       if_ !Flag.Method.split_assert @@
       map_list split_assert); (* TODO: add info *)
    Mark_safe_fun_arg,
      ("Mark safe fun arg",
       if_ !Flag.PredAbst.shift_pred @@
       map @@ Problem.map Effect.mark_safe_fun_arg);
    Abst_polymorphic_comparison,
      ("Abstract polymorphic comparison",
       map Encode.abst_poly_comp);
    Variant_args_to_tuple,
      ("Replace variant arguments with tuples",
       map_term Trans.variant_args_to_tuple);
    Slice,
      ("Slice",
       if_ !Flag.Method.slice @@
       map_with_trans_cex Slice.slice_problem);
    Merge_branch,
      ("Merge the same branches 2",
       map_term Trans.merge_branch);
    CPS,
      ("CPS",
       if_ !Flag.Method.trans_to_CPS @@
       map_with_get_rtyp CPS.trans);
    Remove_pair,
      ("Remove pair",
       if_ !Flag.Method.trans_to_CPS @@
       map_with_get_rtyp Curry.remove_pair);
    Add_occurence_param,
      ("Add occurence parameters",
       if_ !Flag.Method.occurence_param @@
       map_term Trans.add_occurence_param);
    Replace_bottom_def,
      ("Replace bottom def",
       map_term Trans.replace_bottom_def);
    Add_preds_CPS,
      ("Add preds CPS",
       map_option (add_preds Spec.get_abst_cps_env));
    Eliminate_same_arguments,
      ("Eliminate same arguments",
       if_ !Flag.Method.elim_same_arg @@
       map @@ Problem.map Elim_same_arg.trans);
    Insert_unit_param,
      ("Insert unit param",
       if_ !Flag.Method.insert_param_funarg @@
       map_term Trans.insert_param_funarg);
    Alpha_rename,
      ("Alpha renaming",
       if_ Flag.(!mode <> Termination) @@
       map_with_get_rtyp alpha_rename);
  ] [@ocamlformat "disable"]

let pr () =
  if !!Debug_pp.check then Problem.pp
  else if !!Debug_ty.check || !!Debug_ty_wo_check.check then Problem.print_debug
  else Problem.print

let print id desc problem =
  Verbose.printf "%a###[%.3f][#%d]%t %a:@. @[%a@.@." Color.set Color.Green !!Time.get id Color.reset
    Color.s_red desc !!pr problem

let print_if_changed id desc before after =
  if (not (Problem.eq before after)) || !!Debug.check then print id desc after

let print_tree fm t =
  let rec pr indent parent first last t =
    let indent' = if last then indent ^ "  " else indent ^ "│ " in
    let head = if first then "" else if last then "└─" else "├─" in
    match t with
    | Before { id; time } ->
        Format.fprintf fm "%s%s[#%d %a@@ %.3f%t] %s@\n" indent head id Color.set Color.Green time
          Color.reset parent
    | After { node = { id; time }; descr; children; next } ->
        let len = List.length children in
        let flag = if next <> None then "+" else "" in
        Format.fprintf fm "%s%s%s[#%d %a@@ %.3f%t] %s@\n" indent head flag id Color.set Color.Green
          time Color.reset parent;
        List.iteri (fun i t -> pr indent' descr false (i = len - 1) t) @@ List.rev children
  in
  pr "" "Init" true true t

let check_init ~ty ~fv ~lid ~descr problem =
  if !Flag.Preprocess.check_flag && (ty || fv || lid) then (
    let before = Problem.safety Term_util.Term.unit in
    let after = problem in
    Color.printf Green {|### Check "%s"@.|} descr;
    if ty then Check.type_ problem;
    if fv then Check.fv ~force:true ~before ~after;
    if lid then Check.lid problem;
    Color.printf Green "### Check DONE@.@.")

let check ~ty ~fv ~lid ~descr ~before ~after =
  if !Flag.Preprocess.check_flag && (ty || fv || lid) then (
    Color.printf Green {|### Check "%s"@.|} descr;
    if ty then Check.type_ after;
    if fv then Check.fv ~force:true ~before ~after;
    if fv then Check.free_types ~before ~after;
    if lid then Check.lid after;
    Color.printf Green "### Check DONE@.@.")

let verif_result_of_CEGAR_result
    (make_get_rtyp : (CEGAR_syntax.var -> CEGAR_ref_type.t) -> Trans.get_rtyp) (r : CEGAR.result) :
    verif_result =
  match r with
  | Safe env -> Safe (make_get_rtyp (List.assoc ~eq:( = ) -$- env))
  | Unsafe (sol, orig) ->
      let vals_main = lazy (List.map Term_util.Term.int sol, None) in
      Unsafe { vals_main; orig }
  | Unknown _ -> Unknown "" (* TODO *)

(* TODO: case of both results are Safe *)
let merge_and_result r1 r2 =
  match (r1, r2) with
  | Safe _, r | r, Safe _ -> r
  | (Unsafe _ as r), _ | _, (Unsafe _ as r) -> r
  | Unknown _, Unknown _ -> Unknown ""

(* N.B.: non-commutative *)
let merge_or_result prev next =
  match (prev, next) with
  | Unsafe _, Unsafe _ -> next
  | _, Unsafe _ -> prev
  | (Safe _ as r), _ | _, (Safe _ as r) -> r
  | (Unknown _ as r), _ | _, (Unknown _ as r) -> r

let cex_opt = function Unsafe cex -> Some cex | _ -> None
let get_rtyp_opt = function Safe get_rtyp -> Some get_rtyp | _ -> None
let get_rtyp_of_or = List.find_map get_rtyp_opt
let get_rtyp_of_and = List.map (Option.get -| get_rtyp_opt)

type verif_result_with = id * info * verif_result

let make_get_rtyp op { make_get_rtyp = make } (rs : verif_result_with list) : Trans.get_rtyp =
  let get = Triple.trd |- get_rtyp_opt in
  let get_rtyps = lazy (List.filter_map get rs) in
  match make with
  | Some mk -> mk !?get_rtyps
  | None -> (
      match op with
      | Or -> List.find_map get rs
      | And ->
          fun x ->
            let tys = List.map (( @@ ) -$- x) !?get_rtyps in
            let base = Ref_type.to_simple @@ List.hd tys in
            Ref_type.Inter (base, tys))

(* The order of rs matters; the head is the first result *)
let trans_counterexample (_label : after_label) (_op : op) (trans_cex : trans_cex option)
    (rs : verif_result_with list) : counterexample =
  let rs' =
    rs |> List.filter_map (function i, info, Unsafe ce -> Some (i, info, ce) | _ -> None)
  in
  match trans_cex with
  | None -> Triple.trd @@ List.last rs'
  | Some tr ->
      let vals_main =
        lazy (tr @@ List.map (fun (id, info, { vals_main }) -> (id, info, vals_main)) rs')
      in
      let _, _, { orig } = List.hd rs' (* ASSUME: all the orig are the same *) in
      { vals_main; orig }

let make_result label r op pullback (rs : verif_result_with list) =
  match r with
  | Safe _ -> Safe (make_get_rtyp op pullback rs)
  | Unsafe _ -> Unsafe (trans_counterexample label op pullback.trans_cex rs)
  | Unknown _ -> r

let complete_results (results : results) tree : results =
  let rec comp results tree : (info * verif_result) option * results option =
    match tree with
    | (Before node | After { node }) when IdMap.mem node.id results ->
        (Some (IdMap.find node.id results), None)
    | Before _ -> (None, None)
    | After ({ node; op; next; children; pullback } as label) ->
        let rs, updated =
          List.L.fold_left children ~init:([], None) ~f:(fun (rs, updated) tree ->
              let result, updated' = comp results tree in
              let result' =
                match result with
                | None -> rs
                | Some (_info, r) ->
                    let node = node_of_root tree in
                    (node.id, node.info, r) :: rs
              in
              let updated' =
                match (updated, updated') with
                | Some r1, Some r2 -> Some (r1 +++ r2)
                | Some _, None -> updated
                | None, _ -> updated'
              in
              (result', updated'))
        in
        let rs : verif_result_with list = List.sort (Compare.on Triple.fst) rs in
        let r : verif_result option =
          if rs = [] then None
          else
            let merge = match op with And -> merge_and_result | Or -> merge_or_result in
            rs |> List.map Triple.trd |> List.reduce_left merge |> Option.some
        in
        let r' =
          match (r, op, next) with
          | None, _, _ -> None
          | Some (Safe _), And, Some _ -> None
          | Some (Unsafe _), Or, Some _ -> None
          | Some r, _, _ ->
              let r' = make_result label r op pullback rs in
              Some (node.info, r')
        in
        let r'_with = match r' with None -> IdMap.empty | Some r -> IdMap.singleton node.id r in
        let updated' =
          match (r', updated) with
          | None, _ -> updated
          | Some _, None -> Some r'_with
          | Some _, Some updated -> Some (r'_with +++ updated)
        in
        (r', updated')
  in
  match comp results tree with _, None -> results | _, Some updated -> updated +++ results

let result_of ?(complete = true) (results : results) (tree : tree) =
  let results' = if complete then complete_results results tree else results in
  (results', IdMap.find_opt (id_of_root tree) results')

let get_set_main tree =
  match find_label Set_main tree with
  | [ After { children = [ tree ] } ] -> Some (node_of_root tree)
  | _ -> None

let ready_of children =
  match children with
  | Before { id; info; problem; rest } :: _ -> if rest = [] then Some (id, info, problem) else None
  | _ -> [%invalid_arg]

type result_one_step = {
  ready : ready option;  (** a preprocessed problem that is obtained by the expansion *)
  tree : tree;  (** the resulting tree. *)
  expanded : bool;  (** whether the input tree is expanded or not. *)
  id : int;  (** increased from the input [id] if the tree is expanded and unchanged otherwise*)
}
(** Note: Even if [expanded] is false, [tree'] may be different from [tree] since [next] would be updated to [None]. *)

(** [run_one_step n results tree] expands the input preprocess-tree [tree] just ones. *)
let rec run_one_step (id : int) (results : results) (tree : tree) : result_one_step =
  match tree with
  | Before { rest = [] } -> { ready = None; tree; expanded = false; id }
  | Before ({ rest = (label, (descr, (op, tr))) :: rest } as node) ->
      let ready, tree', id' =
        if label = Init then (
          print 0 descr node.problem;
          if !Flag.Preprocess.stop_after = "Init" then exit 0);
        Debug.printf "[BEGIN] %s@." descr;
        let stop_if () = if !Flag.Preprocess.stop_after = descr then exit 0 in
        let pullback, translated = tr node.problem in
        match translated with
        | None ->
            Debug.printf "[END] %s (without changes)@.@." descr;
            stop_if ();
            let tree' = Before { node with rest } in
            let ready = ready_of [ tree' ] in
            (ready, tree', id)
        | Some ((info, problem), next) ->
            Debug.printf "[END] %s@.@." descr;
            check ~ty:!!Debug_ty.check ~fv:!!Debug_fv.check ~lid:!!Debug_lid.check ~descr
              ~before:node.problem ~after:problem;
            print_if_changed id descr node.problem problem;
            stop_if ();
            let node = { node with rest } in
            let time = !!Time.get in
            let children = [ Before { id; time; info; problem; rest } ] in
            let ready = ready_of children in
            (ready, After { node; op; label; descr; next; children; pullback }, id + 1)
      in
      { ready; tree = tree'; expanded = true; id = id' }
  | After ({ node; descr; children; next } as arg) -> (
      match result_of ~complete:false results tree with
      | _, Some _ -> { ready = None; tree; expanded = false; id }
      | _, None -> (
          let ready, children, expanded, id' =
            List.L.fold_right children ~init:(None, [], false, id)
              ~f:(fun child (ready, acc, expanded, id) ->
                if expanded then (
                  assert (ready = None);
                  (ready, child :: acc, expanded, id))
                else
                  let { ready; tree = child'; expanded; id = id' } =
                    run_one_step id results child
                  in
                  (ready, child' :: acc, expanded, id'))
          in
          if expanded then { ready; tree = After { arg with children }; expanded; id = id' }
          else
            match next with
            | None -> { ready; tree = After { arg with children }; expanded = false; id = id' }
            | Some (Trans tr) -> (
                let ids = List.map id_of_root children in
                let results' = List.filter_map (IdMap.find_opt -$- results) ids in
                match tr results' with
                | None ->
                    {
                      ready;
                      tree = After { arg with children; next = None };
                      expanded = false;
                      id = id';
                    }
                | Some ((info, problem), next) ->
                    print id descr problem;
                    let time = !!Time.get in
                    let children =
                      Before { id; time; info; problem; rest = node.rest } :: children
                    in
                    let ready = ready_of children in
                    {
                      ready;
                      tree = After { arg with children; next };
                      expanded = true;
                      id = id + 1;
                    })))

type result = {
  ready : ready option;
  tree : tree;
  expanded : bool;
  counter : int;
  results : results;
}
(** The meanings of the first three values are the same as [result_one_step]. *)

(** Evaluate multi-steps until a new instance is ready. *)
let rec run counter results (tree : tree) : result =
  let results, r = result_of results tree in
  match r with
  | Some _ -> { ready = None; tree; expanded = false; counter; results }
  | None -> (
      match run_one_step counter results tree with
      | { ready = None; tree = tree'; expanded = true; id = counter' } -> run counter' results tree'
      | { ready = Some _; expanded = false } -> assert false
      | { ready; tree = tree'; expanded = b; id = counter' } ->
          { ready; tree = tree'; expanded = b; counter = counter'; results })

let run counter results (tree : tree) = measure_time (run counter results) tree

let make_init pps problem =
  let time = !!Time.get in
  Before { id = 0; time; problem; info = None; rest = pps }

let check_duplicate pps =
  let ss = List.map (snd |- fst) pps in
  assert (List.length ss = List.length (List.sort compare ss))

let run_problem pps problem =
  if !!Debug.check then check_duplicate pps;
  run 1 IdMap.empty @@ make_init pps problem

let get_problem_of { ready } = ready |> Option.get |> Triple.trd

let run_on_term ?(make = Problem.safety) pps t =
  t |> make |> run_problem pps |> get_problem_of |> Problem.term
